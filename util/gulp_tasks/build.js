// Generated by CoffeeScript 1.6.2
(function() {
  var Buffer, Helper, Q, StreamFuncs, buildLangSrc, coffee, coffeelint, coffeelintOptions, compileCoffeeOnlyRegex, compileDev, compileIgnorePath, es, gulp, gulpif, gutil, jshint, lrServer, path, setupCompileStream, tinylr, verbose, walk, watch;

  gulp = require("gulp");

  gutil = require("gulp-util");

  path = require("path");

  Buffer = require('buffer').Buffer;

  es = require("event-stream");

  Q = require("q");

  walk = require("walkdir");

  tinylr = require("tiny-lr");

  coffee = require("gulp-coffee");

  coffeelint = require("gulp-coffeelint");

  jshint = require("gulp-jshint");

  gulpif = require("gulp-if");

  buildLangSrc = require("../../config/lang");

  coffeelintOptions = {
    indentation: {
      level: "ignore"
    },
    no_tabs: {
      level: "ignore"
    },
    max_line_length: {
      level: "ignore"
    }
  };

  compileIgnorePath = /.src.(test|vender|ui)/;

  compileCoffeeOnlyRegex = /.src.(service|model)/;

  verbose = true;

  lrServer = null;

  Helper = {
    shouldLintCoffee: function(f) {
      return !f.path.match(compileCoffeeOnlyRegex);
    },
    endsWith: function(string, pattern) {
      var idx, startIdx;

      if (string.length < pattern.length) {
        return false;
      }
      idx = 0;
      startIdx = string.length - pattern.length;
      while (idx < pattern.length) {
        if (string[startIdx + idx] !== pattern[idx]) {
          return false;
        }
        ++idx;
      }
      return true;
    },
    createLrServer: function() {
      if (lrServer) {
        return;
      }
      gutil.log(gutil.colors.bgBlue(" Starting livereload server... "));
      lrServer = tinylr();
      lrServer.listen(35729, function(err) {
        if (err) {
          gutil.log("[LR Error]", "Cannot start livereload server");
          lrServer = null;
        }
        return null;
      });
      return null;
    },
    log: function(e) {
      return console.log(e);
    },
    noop: function() {}
  };

  StreamFuncs = {
    lintReporter: require('./reporter'),
    throughLiveReload: function() {
      return es.through(function(file) {
        if (lrServer) {
          if (verbose) {
            console.log("[LiveReload]", file.replace(process.cwd(), "."));
          }
          lrServer.changed({
            body: {
              files: [filePath]
            }
          });
        }
        this.emit('data', file);
        return null;
      });
    },
    coffeeErrorPrinter: function(error) {
      console.log(gutil.colors.red.bold("\n[CoffeeError]"), error.message.replace(process.cwd(), "."));
      return null;
    },
    throughLangSrc: function() {
      var gruntMock, pipeline,
        _this = this;

      pipeline = es.through(function(file) {
        console.log("[Compiling] lang-souce.coffee");
        buildLangSrc.run(gruntMock, Helper.noop);
        return null;
      });
      gruntMock = {
        log: {
          error: Helper.log
        },
        file: {
          write: function(p1, p2) {
            var cwd;

            cwd = process.cwd();
            pipeline.emit("data", new gutil.File({
              cwd: cwd,
              base: cwd,
              path: p1,
              contents: new Buffer(p2)
            }));
            return null;
          }
        }
      };
      return pipeline;
    }
  };

  setupCompileStream = function(stream) {
    var assetBranch, coffeeBranch, coffeeCompile, langSrcBranch;

    assetBranch = StreamFuncs.throughLiveReload();
    langSrcBranch = StreamFuncs.throughLangSrc();
    langSrcBranch.pipe(gulp.dest("."));
    coffeeBranch = gulpif(Helper.shouldLintCoffee, coffeelint(void 0, coffeelintOptions));
    coffeeCompile = coffeeBranch.pipe(coffee({
      bare: true
    }));
    coffeeCompile.pipe(es.through(function(f) {
      console.log("[Compile] " + f.relative);
      return this.emit("data", f);
    })).pipe(gulpif(Helper.shouldLintCoffee, jshint())).pipe(gulpif(Helper.shouldLintCoffee, StreamFuncs.lintReporter())).pipe(gulp.dest("."));
    coffeeCompile.removeAllListeners("error");
    coffeeCompile.on("error", StreamFuncs.coffeeErrorPrinter);
    return stream.pipe(gulpif(/lang-source\.coffee/, langSrcBranch, true)).pipe(gulpif(/src.assets/, assetBranch, true)).pipe(gulpif(/\.coffee$/, coffeeBranch, true));
  };

  watch = function() {};

  compileDev = function(allCoffee) {
    var deferred;

    if (allCoffee) {
      path = ["src/**/*.coffee", "!src/test/**/*"];
    } else {
      path = ["src/**/*.coffee", "!src/test/**/*", "!src/service/**/*", "!src/model/**/*"];
    }
    deferred = Q.defer();
    setupCompileStream(gulp.src(path, {
      cwdbase: true
    })).on("end", function() {
      return deferred.resolve();
    });
    return deferred.promise;
  };

  module.exports = {
    watch: watch,
    compileDev: compileDev
  };

}).call(this);

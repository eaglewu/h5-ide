<!DOCTYPE HTML>
<html>
<head>
	<title>MadeiraCloud - Visual Cloud Computing IDE</title>
	<meta charset="UTF-8" />
	<link rel="stylesheet" type="text/css" href="./assets/css/core.css" />
	<link rel="stylesheet" type="text/css" href="./assets/css/ide.css" />
	<link rel="stylesheet" type="text/css" href="./assets/css/grid.css" />
	<link rel="stylesheet" type="text/css" href="./assets/css/UI.component.css" />
	<link rel="stylesheet" type="text/css" href="./assets/css/canvas.css" />

	<style type="text/css">
	html, body {
		overflow: scroll;
	}

	#body {
		position: static;
	}
	</style>

	<script type="text/javascript">
		document.write( "<s"+"cript type='text/javascript' src='./lib/version.js?" + Math.random() + "'></scr"+"ipt>" );
	</script>

	<script type='text/javascript' src='./vender/requirejs/require.js' data-main='./js/ide/config.js'></script>

	<script type='text/javascript' src='./vender/jquery/jquery.js'></script>
	<script type='text/javascript' src='./lib/MC.core.js'></script>
	<script type='text/javascript' src='./lib/MC.canvas.js'></script>
	<script type='text/javascript' src='./vender/canvon/canvon.js'></script>
	<script type='text/javascript' src='./lib/MC.canvas.constant.js'></script>
	<script type='text/javascript' src='./lib/MC.canvas.add.js'></script>
	<script type='text/javascript' src='./lib/MC.canvas.line.js'></script>
	<script type='text/javascript' src='./ui/common/UI.tabbar.js'></script>

	<script type="text/javascript">
	$(document).ready(function ()
	{
		Tabbar.current = 'stack';

		require([
			'./module/design/canvas/model.js',
			'./lib/aws/aws.js',
			'./lib/aws/ec2/eip.js'
		], function (model, aws, eip)
		{
			MC.aws = aws;
			MC.aws.eip = eip;

			$.getJSON( './import-test-crayfish.json', function(data)
			{
				Tabbar.current = 'stack';

				MC.canvas_data = data;

				var component_data = data.component,
					layout_data = data.layout,

					resources = {},
					resource_stack = {},
					
					elb_child_stack = [],
					elb_connection,

					GROUP_INNER_PADDING = 2,
					GROUP_MARGIN = 2,

					VPC_PADDING_LEFT = 20,
					VPC_PADDING_TOP = 10,
					VPC_PADDING_RIGHT = 8,
					VPC_PADDING_BOTTOM = 5,

					ELB_START_LEFT = 14,
					ELB_SIZE = MC.canvas.COMPONENT_SIZE['AWS.ELB'],

					// Initialize group construction
					SUBGROUP = {
						'AWS.VPC.VPC': ['AWS.EC2.AvailabilityZone'],
						'AWS.EC2.AvailabilityZone': ['AWS.VPC.Subnet'],
						'AWS.VPC.Subnet': [
							'AWS.EC2.Instance',
							'AWS.AutoScaling.Group',
							'AWS.VPC.NetworkInterface'
						],
						'AWS.AutoScaling.Group': ['AWS.AutoScaling.LaunchConfiguration']
					},

					SORT_ORDER = {
						'AWS.AutoScaling.Group': 1,
						'AWS.EC2.Instance': 2,
						'AWS.VPC.NetworkInterface': 3
					},

					GROUP_DEFAULT_SIZE = {
						'AWS.VPC.VPC': [60, 60],
						'AWS.EC2.AvailabilityZone': [17, 17],
						'AWS.VPC.Subnet': [15, 15],
						'AWS.AutoScaling.Group' : [13, 13]
					},

					// For childeren node order
					POSITION_METHOD = {
						'AWS.VPC.VPC': 'vertical',
						'AWS.EC2.AvailabilityZone': 'horizontal',
						'AWS.VPC.Subnet': 'matrix',
						'AWS.AutoScaling.Group': 'center'
					},

					layout,
					previous_node;
					
				$.each(data.layout.component.node, function (key, value)
				{
					resources[ key ] = value;
				});

				$.each(data.layout.component.group, function (key, value)
				{
					resources[ key ] = value;
				});

				$.each(resources, function (key, value)
				{
					var type = value.type.replace(/\./ig, '-');

					stack = resource_stack[ type ];

					if (stack === undefined)
					{
						resource_stack[ type ] = [];
					}

					resource_stack[ type ].push(key);
				});

				layout = {
					'id': resource_stack[ 'AWS-VPC-VPC' ][0],
					'coordinate': [5, 3],
					'size': [0, 0],
					'type': 'AWS.VPC.VPC'
				};

				// ELB connected children
				if (resource_stack[ 'AWS-ELB' ] !== undefined)
				{
					$.each(resource_stack[ 'AWS-ELB' ], function (current_index, id)
					{
						elb_connection = layout_data.component.node[ id ].connection;

						$.each(elb_connection, function (i, item)
						{
							if (item.port === 'elb-sg-out')
							{
								elb_child_stack.push( item.target );
							}
						});
					});
				}

				function searchChild(id)
				{
					var children = [],
						target_group = SUBGROUP[ resources[ id ].type ],
						node_data,
						node_child;

					$.each(resources, function (key, value)
					{
						if (
							$.inArray(resources[ key ].type, target_group) > -1 &&
							value.groupUId === id
						)
						{
							node_child = searchChild(key);

							node_data = {
								'id': key,
								'coordinate': [0, 0],
								'size': [0, 0],
								'type': value.type
							};

							if (MC.canvas.COMPONENT_SIZE[ value.type ] !== undefined)
							{
								node_data.size = MC.canvas.COMPONENT_SIZE[ value.type ];
							}

							if (GROUP_DEFAULT_SIZE[ value.type ] !== undefined)
							{
								node_data.size = GROUP_DEFAULT_SIZE[ value.type ];
							}

							if (node_child)
							{
								node_data[ 'children' ] = node_child;
							}

							children.push(node_data);
						}
					});

					return children.length < 1 ? false : children;
				}

				node_child = searchChild( resource_stack[ 'AWS-VPC-VPC' ][0] );

				if (node_child)
				{
					layout[ 'children' ] = node_child;
				}

				function checkChild(node)
				{
					if (node.children !== undefined)
					{
						var count = 0;

						$.each(node.children, function (i, item)
						{
							count += checkChild(item);
						});

						node[ 'totalChild' ] = count + node.children.length;

						if (node.type === 'AWS.VPC.Subnet')
						{
							node.hasELBConnected = false;

							$.each(node.children, function (i, item)
							{
								if ($.inArray(item.id, elb_child_stack) > -1)
								{
									node.hasELBConnected = true;
								}

								if (item.type === 'AWS.AutoScaling.Group')
								{
									if (
										item.children !== undefined &&
										$.inArray(item.children[ 0 ].id, elb_child_stack) > -1
									)
									{
										node.hasELBConnected = true;
									}
								}
							});
						}

						return node.children.length;
					}
					else
					{
						node[ 'totalChild' ] = 0;

						if (node.type === 'AWS.VPC.Subnet')
						{
							node.hasELBConnected = false;
						}

						return 0;
					}
				}

				checkChild( layout );

				function sortChild(node)
				{
					if (node.children !== undefined)
					{
						if (node.type === 'AWS.EC2.AvailabilityZone')
						{
							node.children.sort(function (a, b)
							{
								if (
									(a.hasELBConnected === true && b.hasELBConnected === true)
									||
									(a.hasELBConnected === false && b.hasELBConnected === false)
								)
								{
									return b.totalChild - a.totalChild;
								}
								else
								{
									if (
										a.hasELBConnected === true &&
										b.hasELBConnected === false
									)
									{
										return -1;
									}

									if (
										a.hasELBConnected === false &&
										b.hasELBConnected === true
									)
									{
										return 1;
									}
								}
							});
						}
						else
						{
							node.children.sort(function (a, b)
							{
								return b.totalChild - a.totalChild;
							});
						}

						$.each(node.children, function (i, item)
						{
							sortChild( item );
						});
					}
				}

				sortChild( layout );

				function absPosition(node, x, y)
				{
					node.coordinate[0] += x;
					node.coordinate[1] += y;

					if (node.children !== undefined)
					{
						$.each(node.children, function (i, item)
						{
							absPosition(item, node.coordinate[0], node.coordinate[1]);
						});
					}
				}

				absPosition( layout, 0, 0 );

				function positionSubnetChild(node)
				{
					var stack = {},
						children = node.children,
						length = children.length,
						method = POSITION_METHOD[ node.type ],
						max_width = 0,
						max_height = 0,

						NODE_MARGIN_LEFT = 2,
						NODE_MARGIN_TOP = 2,

						elb_connected_instance = [],
						normal_instance = [],
						hasUniqueInstanceConnectedToELB = false,

						max_column = Math.ceil( Math.sqrt( length ) ),
						max_row = length === 0 ? 0 : Math.ceil( length / max_column ),
						column_index = 0,
						row_index = 0;

					children.sort(function (a, b)
					{
						return SORT_ORDER[ a.type ] - SORT_ORDER[ b.type ];
					});

					$.each(children, function (current_index, item)
					{
						if (stack[ item.type ] === undefined)
						{
							stack[ item.type ] = [];
						}

						stack[ item.type ].push( item );
					});

					if (stack[ 'AWS.EC2.Instance' ] !== undefined)
					{
						$.each(stack[ 'AWS.EC2.Instance' ], function (i, item)
						{
							if ($.inArray(item.id, elb_child_stack) > -1)
							{
								elb_connected_instance.push( item );
							}
							else
							{
								normal_instance.push( item );
							}
						});

						elb_connected_instance.sort(function (a, b)
						{
							return MC.canvas_data.component[ a.id ].name.localeCompare( MC.canvas_data.component[ b.id ].name );
						});

						normal_instance.sort(function (a, b)
						{
							return MC.canvas_data.component[ a.id ].name.localeCompare( MC.canvas_data.component[ b.id ].name );
						});
					}

					if (stack[ 'AWS.AutoScaling.Group' ] !== undefined)
					{
						var childLength = stack[ 'AWS.AutoScaling.Group' ].length,
							//elb_connected_instance = [],
							row_index = 0;

						$.each(stack[ 'AWS.AutoScaling.Group' ], function (i, item)
						{
							item.coordinate = [
								GROUP_INNER_PADDING,
								row_index * 9 + (row_index * NODE_MARGIN_TOP) + GROUP_INNER_PADDING
							];

							if (item.children !== undefined)
							{
								positionChild( item );
							}

							row_index++;
						});

						$.each(elb_connected_instance, function (i, item)
						{
							item.coordinate = [
								// Adjust instance x axis with ASG (+2)
								GROUP_INNER_PADDING + 2,
								// Adjust instance y axis with ASG (+4)
								row_index * 9 + (row_index * NODE_MARGIN_TOP) + GROUP_INNER_PADDING + 4
							];

							row_index++;
						});
					}
					else
					{
						var row_index = 0;

						if (stack[ 'AWS.EC2.Instance' ] !== undefined)
						{
							if (elb_connected_instance.length > 0)
							{
								hasUniqueInstanceConnectedToELB = true;
							}

							$.each(elb_connected_instance, function (i, item)
							{
								item.coordinate = [
									GROUP_INNER_PADDING,
									row_index * 9 + (row_index * NODE_MARGIN_TOP) + GROUP_INNER_PADDING
								];

								row_index++;
							});
						}
					}

					if (normal_instance.length > 0)
					{
						var childLength = normal_instance.length,
							max_child_column = Math.ceil( Math.sqrt( childLength ) ),
							max_child_row = childLength === 0 ? 0 : Math.ceil( childLength / max_child_column ),
							column_index = 0,
							row_index = 0;

						$.each(normal_instance, function (i, item)
						{
							if (column_index >= max_child_column)
							{
								column_index = 0;
								row_index++;
							}

							item.coordinate = [
								column_index * 9 + (column_index * NODE_MARGIN_LEFT) + GROUP_INNER_PADDING,
								row_index * 9 + (row_index * NODE_MARGIN_LEFT) + GROUP_INNER_PADDING
							];

							column_index++;
						});
					}

					if (stack[ 'AWS.VPC.NetworkInterface' ] !== undefined)
					{
						var childLength = stack[ 'AWS.VPC.NetworkInterface' ].length;

						var max_child_column = Math.ceil( Math.sqrt( childLength ) ),
							max_child_row = childLength === 0 ? 0 : Math.ceil( childLength / max_child_column ),
							column_index = 0,
							row_index = 0;

						$.each(stack[ 'AWS.VPC.NetworkInterface' ], function (i, item)
						{
							if (column_index >= max_child_column)
							{
								column_index = 0;
								row_index++;
							}

							item.coordinate = [
								column_index * 9 + (column_index * NODE_MARGIN_LEFT) + GROUP_INNER_PADDING,
								row_index * 9 + (row_index * NODE_MARGIN_LEFT) + GROUP_INNER_PADDING
							];

							column_index++;
						});
					}

					if (stack[ 'AWS.EC2.Instance' ] !== undefined)
					{
						var offset_left = 0;

						if (stack[ 'AWS.AutoScaling.Group' ] !== undefined)
						{
							offset_left += 13 + NODE_MARGIN_LEFT;
						}

						if (hasUniqueInstanceConnectedToELB)
						{
							offset_left += 11;
						}

						$.each(normal_instance, function (i, item)
						{
							item.coordinate[0] += offset_left;
						});
					}

					if (stack[ 'AWS.VPC.NetworkInterface' ] !== undefined)
					{
						var offset_left = 0;

						if (stack[ 'AWS.AutoScaling.Group' ] !== undefined)
						{
							offset_left += 13 + NODE_MARGIN_LEFT;
						}

						if (hasUniqueInstanceConnectedToELB)
						{
							offset_left += 11;
						}

						if (normal_instance.length > 0)
						{
							offset_left += Math.ceil( Math.sqrt( normal_instance.length ) ) * 9;

							offset_left += 4;
						}

						$.each(stack[ 'AWS.VPC.NetworkInterface' ], function (i, item)
						{
							item.coordinate[0] += offset_left;
						});
					}

					var max_width = 0,
						max_height = 0,
						item_coordinate,
						component_size;

					$.each(children, function (i, item)
					{
						item_coordinate = item.coordinate;

						component_size = MC.canvas.COMPONENT_SIZE[ item.type ];

						if (item_coordinate[0] + component_size[0] > max_width)
						{
							max_width = item_coordinate[0] + component_size[0];
						}

						if (item_coordinate[1] + component_size[1] > max_height)
						{
							max_height = item_coordinate[1] + component_size[1];
						}
					});

					node.size = [
						max_width + GROUP_INNER_PADDING,
						max_height + GROUP_INNER_PADDING
					];
				}

				function positionChild(node)
				{
					var children = node.children,
						GROUP_MARGIN = 2,

						length = children.length,
						method = POSITION_METHOD[ node.type ],
						max_width = 0,
						max_height = 0,

						NODE_MARGIN_LEFT = 2,
						NODE_MARGIN_TOP = 2;

					if (node.type === 'AWS.EC2.AvailabilityZone')
					{
						GROUP_MARGIN = 4;
					}

					if (method === 'matrix')
					{
						positionSubnetChild(node);
					}

					if (method === 'vertical')
					{
						$.each(children, function (current_index, item)
						{
							item.coordinate = [
								0 + GROUP_INNER_PADDING,
								current_index + GROUP_INNER_PADDING
							];

							if (item.children !== undefined)
							{
								positionChild( item );
							}

							if (item.size[0] > max_width)
							{
								max_width = item.size[0];
							}

							max_height += item.size[1];

							if (current_index > 0)
							{
								previous_node = children[ current_index - 1 ];
								item.coordinate = [
									0 + GROUP_INNER_PADDING,
									previous_node.size[1] + previous_node.coordinate[1] + GROUP_MARGIN
								];

								max_height += GROUP_MARGIN * 2;
							}
						});

						node.size = [
							max_width + (GROUP_INNER_PADDING * 2),
							max_height + (GROUP_MARGIN * (length - 1)) + GROUP_INNER_PADDING
						];
					}

					if (method === 'horizontal')
					{
						$.each(children, function (current_index, item)
						{
							item.coordinate = [
								current_index + GROUP_INNER_PADDING,
								0 + GROUP_INNER_PADDING
							];

							if (item.children !== undefined)
							{
								positionChild( item );
							}

							if (item.size[1] > max_height)
							{
								max_height = item.size[1];
							}

							max_width += item.size[0];

							if (current_index > 0)
							{
								previous_node = children[ current_index - 1 ];
								item.coordinate = [
									previous_node.size[0] + previous_node.coordinate[0] + GROUP_MARGIN,
									0 + GROUP_INNER_PADDING
								];

								max_width += GROUP_MARGIN * 2;
							}
						});

						node.size = [
							max_width - (GROUP_MARGIN * (length - 1)) + (GROUP_INNER_PADDING * 2),
							max_height + (GROUP_INNER_PADDING * 2)
						];
					}

					if (method === 'center')
					{
						$.each(children, function (current_index, item)
						{
							item.coordinate = [2, 2];
						});

						node.size = [13, 13];
					}
				}

				positionChild( layout );

				// VPC padding
				$.each(layout.children, function (i, item)
				{
					item.coordinate[0] += VPC_PADDING_LEFT;
					item.coordinate[1] += VPC_PADDING_TOP;
				});

				// ELB
				if (resource_stack[ 'AWS-ELB' ] !== undefined)
				{
					resource_stack[ 'AWS-ELB' ].sort(function (a, b)
					{
						return component_data[ b ].resource.Scheme.localeCompare( component_data[ a ].resource.Scheme );
					});

					$.each(resource_stack[ 'AWS-ELB' ], function (current_index, id)
					{
						resources[ id ].coordinate = [
							ELB_START_LEFT + (current_index * 10) + (current_index * 10),
							layout.children[ 0 ].coordinate[ 1 ] + layout.children[ 0 ].size[ 1 ] + 5
						];
					});
				}

				// RouteTable
				if (resource_stack[ 'AWS-VPC-RouteTable' ] !== undefined)
				{
					var ROUTE_TABLE_START_LEFT = 15,
						ROUTE_TABLE_START_TOP = 5,
						ROUTE_TABLE_MARGIN = 4,
						ROUTE_TABLE_SIZE = MC.canvas.COMPONENT_SIZE['AWS.VPC.RouteTable'],
						RT_to_IGW = [],
						RT_to_VGW = [],
						RT_other = [],
						RT_prefer,
						RT_connection,
						RT_connect_target;

					if (resource_stack[ 'AWS-VPC-RouteTable' ].length > 0)
					{
						resource_stack[ 'AWS-VPC-RouteTable' ].sort(function (a, b)
						{
							return MC.canvas_data.component[ a ].name.localeCompare( MC.canvas_data.component[ b ].name );
						});

						$.each(resource_stack[ 'AWS-VPC-RouteTable' ], function (index, id)
						{
							RT_prefer = false;
							RT_connection = layout_data.component.node[ id ].connection;
							
							$.each(RT_connection, function (i, data)
							{
								if (data.port === 'rtb-tgt')
								{
									RT_connect_target = layout_data.component.node[ data.target ].type;

									if (RT_connect_target === 'AWS.VPC.InternetGateway')
									{
										RT_prefer = true;
										RT_to_IGW.push( id );
									}

									if (RT_connect_target === 'AWS.VPC.VPNGateway')
									{
										RT_prefer = true;
										RT_to_VGW.push( id );
									}

								}
							});

							if (RT_prefer === false)
							{
								RT_other.push( id );
							}
						});

						// RT Children join
						resource_stack[ 'AWS-VPC-RouteTable' ] = _.unique( RT_to_IGW.concat(RT_to_VGW, RT_other) );

						$.each(resource_stack[ 'AWS-VPC-RouteTable' ], function (current_index, id)
						{
							resources[ id ].coordinate = [
								(current_index + 1) * ROUTE_TABLE_SIZE[0] + ((current_index + 1) * ROUTE_TABLE_MARGIN) + ROUTE_TABLE_START_LEFT,
								ROUTE_TABLE_START_TOP
							];
						});
					}
				}

				// Add AZ margin for ELB
				if (
					layout.children !== undefined &&
					layout.children.length > 1 &&
					resource_stack[ 'AWS-ELB' ] !== undefined &&
					resource_stack[ 'AWS-ELB' ].length > 1
				)
				{
					var i = 1,
						l = layout.children.length;

					for ( ; i < l ; i++ )
					{
						layout.children[ i ].coordinate[ 1 ] += 15;
					}

					layout.size[ 1 ] += 10;
				}

				function absPosition(node, x, y)
				{
					var coordinate = node.coordinate;

					coordinate[0] += x;
					coordinate[1] += y;

					if (node.children !== undefined)
					{
						$.each(node.children, function (i, item)
						{
							absPosition(item, coordinate[0], coordinate[1]);
						});
					}
				}

				function updateLayoutData(node)
				{
					var resource = resources[ node.id ];

					resource.coordinate = node.coordinate;

					if (resource.size !== undefined)
					{
						resource.size = node.size;
					}

					if (node.children !== undefined)
					{
						$.each(node.children, function (i, item)
						{
							updateLayoutData( item );
						});
					}
				}

				absPosition( layout, 0, 0 );

				function VPCsize()
				{
					var VPC_max_width = 0,
						VPC_max_height = 0,
						layout_data = data.layout.component,
						ignore_type = ['AWS.VPC.CustomerGateway', 'AWS.VPC.InternetGateway', 'AWS.VPC.VPNGateway'],
						component_size,
						item_type;

					$.each(layout_data.node, function (i, item)
					{
						if ($.inArray(item.type, ignore_type) === -1)
						{
							component_size = MC.canvas.COMPONENT_SIZE[ item.type ];

							if (item.coordinate[0] + component_size[0] > VPC_max_width)
							{
								VPC_max_width = item.coordinate[0] + component_size[0];
							}

							if (item.coordinate[1] + component_size[1] > VPC_max_height)
							{
								VPC_max_height = item.coordinate[1] + component_size[1];
							}
						}
					});

					$.each(layout_data.group, function (i, item)
					{
						group_size = item.size;

						if (item.type !== 'AWS.AutoScaling.Group')
						{
							if (item.coordinate[0] + group_size[0] > VPC_max_width)
							{
								VPC_max_width = item.coordinate[0] + group_size[0];
							}

							if (item.coordinate[1] + group_size[1] > VPC_max_height)
							{
								VPC_max_height = item.coordinate[1] + group_size[1];
							}
						}
					});

					layout.size[0] = VPC_max_width - layout.coordinate[0] + VPC_PADDING_RIGHT;
					layout.size[1] = VPC_max_height - layout.coordinate[1] + VPC_PADDING_BOTTOM;
				}

				updateLayoutData( layout );

				VPCsize();

				// IGW & VGW
				if (resource_stack[ 'AWS-VPC-InternetGateway' ] !== undefined)
				{
					resources[ resource_stack[ 'AWS-VPC-InternetGateway' ][ 0 ] ].coordinate = [
						layout.coordinate[0] - 4,
						layout.coordinate[1] + (layout.size[1] / 2) - 4
					];
				}

				if (resource_stack[ 'AWS-VPC-VPNGateway' ] !== undefined)
				{
					resources[ resource_stack[ 'AWS-VPC-VPNGateway' ][ 0 ] ].coordinate = [
						layout.coordinate[0] + layout.size[0] - 4,
						layout.coordinate[1] + (layout.size[1] / 2) - 4
					];
				}

				// CGW
				if (resource_stack[ 'AWS-VPC-CustomerGateway' ] !== undefined)
				{
					resources[ resource_stack[ 'AWS-VPC-CustomerGateway' ][ 0 ] ].coordinate = [
						layout.coordinate[0] + layout.size[0] + 8,
						layout.coordinate[1] + (layout.size[1] / 2) - 4
					];
				}

				console.info(layout);

				MC.canvas.layout.init();
				model.initLine();
				model.reDrawSgLine();

			});
		});
	});
	</script>
</head>
<body id="body">
<div id="canvas" class="canvas-svg-group">
<div id="canvas_content">
<div id="canvas_container" style="width: 2400px; height: 2400px;" class="canvas_state_stack">
	<div id="canvas_body" class="canvas-view-normal">
		<svg id="svg_canvas" xmlns="http://www.w3.org/2000/svg" version="1.2">
			<defs>
				<filter id="grayscale">
					<feColorMatrix type="matrix" values="0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"/>
				</filter>
			</defs>
			<line id="svg_padding_line" x1="0" y1="0" x2="1" y2="1"/>
			<g id="group_layer">
				<g id="vpc_layer"></g>
				<g id="az_layer"></g>
				<g id="subnet_layer"></g>
				<g id="asg_layer"></g>
			</g>
			<g id="line_layer"></g>
			<g id="node_layer"></g>
		</svg>
	</div>
</div>
</div>
</div>
</body>
</html>
